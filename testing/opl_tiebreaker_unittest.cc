/* STUDENTS:  DO NOT EDIT THIS FILE.  INSTEAD, MODIFY YOUR OWN PROJECT
 * CODE TO FIT THE SPECIFICATION GIVEN BY THE TESTS IN THIS FILE.
 *
 * If you DO modify it, we overwrite it with a fresh version from our repo
 * when grading, so you can't use it to fudge the tests anyway.
 *
 * This file is used by the CS5801 auto-grading system.
 *
 * Please note, the assessment tests for grading, will use the same include
 * files, class names, and function names for accessing students' code that you
 * find in this file.  So students, if you write your code so that it passes
 * these feedback tests, you can be assured that the auto-grader will at least
 * be able to properly link with your code.
 */
/*******************************************************************************
* This test file are inspired by CS5801 Fall 2019
******************************************************************************/
 #ifdef OPL_TIEBREAKER_TEST

/*******************************************************************************
 * Includes
 ******************************************************************************/
#include <cmath>
#include <gtest/gtest.h>
#include "src/opl.h"
#include <string>
#include <unistd.h>
using namespace std;
class OPLTiebreakerTest : public ::testing::Test {

 protected:
  virtual void SetUp() {
    // Initialize anything for TESTS
    opl->ReadFile("opl_tiebreaker_1.csv");
  }

  OPL *opl = new OPL();
};

/*******************************************************************************
 * Test Cases
 ******************************************************************************/

TEST_F(OPLTiebreakerTest, AuditOPLFile) {
  opl->Audit();
  EXPECT_EQ(opl->report_.GetNumTotalCandidates(), 7 ) << "FAIL: oplReadFileTest:ReadFile - TotalCandidates is incorrect";
  EXPECT_EQ(opl->report_.GetNumBallots(), 100 ) << "FAIL: oplReadFileTest:ReadFile - NumBallots is incorrect";
  EXPECT_EQ(opl->report_.GetNumTotalSeats(), 3 ) << "FAIL: oplReadFileTest:ReadFile - TotalSeats is incorrect";


  /*
  Scenario:
  2 of the D party gets 25 votes each.
  2 of the R party gets 25 votes each.
  Only 3 seats.
  So the two parties will be tied with 50 vs 50 votes.
  After tiebreaking, the party that did not get the extra seat
  will have a tie situation again with 2 candidates 25 vs 25 votes,
  but only 1 seat.
  To summarize, tiebreaker comes in twice, once for parties,
  once for candidates.
  */

  // There should only be 2 winner parties
  EXPECT_EQ(opl->report_.GetWinnerParty().size(), 2 ) << "FAIL: GetWinnerParty";
  // D and R should at least have 1 seat
  int ori_party_size_1 = opl->report_.GetWinnerParty()[0].list_candidates_.size();
  int ori_party_size_2 = opl->report_.GetWinnerParty()[1].list_candidates_.size();
  EXPECT_GE(ori_party_size_1, 1 ) << "FAIL";
  EXPECT_GE(ori_party_size_2, 1 ) << "FAIL";

  // Sum of seats should be 3
  EXPECT_EQ(ori_party_size_1 + ori_party_size_2, 3 ) << "FAIL";

  // Run Audit for 21 times
  // If any of the times the party size has changed
  // We know the tiebreaker has done something.
  bool party_is_random = false;
  for (int i = 0; i < 21; i++) {
    opl->Audit();
    if (ori_party_size_1 != opl->report_.GetWinnerParty()[0].list_candidates_.size()) {
      party_is_random = true;
      break;
    }
  }
  EXPECT_EQ(party_is_random, true ) << "FAIL: Tiebreaker does not show randomness in tied parties in 21 runs!";

  int one_seat_index = -1;  // Save the index of the party that has only one seat
  if (opl->report_.GetWinnerParty()[0].list_candidates_.size() == 1){
    one_seat_index = 0;
  } else if (opl->report_.GetWinnerParty()[1].list_candidates_.size() == 1) {
    one_seat_index = 1;
  }
  EXPECT_GE(one_seat_index, 0 ) <<
      "FAIL: Tiebreaker does not recognize a party with a single seat";

  // Set up for exhaustive testing for randomness
  std::string first_choice = opl->report_.GetWinnerParty()[one_seat_index].list_candidates_[0].GetName();
  std::string second_choice;

  if (first_choice == "Pike") {
    second_choice = "Foster";
  } else if (first_choice == "Foster") {
    second_choice = "Pike";
  } else if (first_choice == "Deutsch") {
    second_choice = "Borg";
  } else if (first_choice == "Borg") {
    second_choice = "Deutsch";
  } else {
    std::cout << "Unknown error!" << std::endl;
  }

  bool candidate_is_random = false;
  if (one_seat_index >= 0) {  // Prevents out of bound index reading
    // If at any time during the 21 runs,
    // the party that gets only 1 seats AND
    // the candidate has the same name as second_choice
    // we know that first_choice has lost in the tiebreaker,
    // therefore proving that tiebreaker is working.
    for (int i = 0; i < 1000; i++) {
      opl->Audit();
      if (opl->report_.GetWinnerParty()[0].list_candidates_.size() == 1 &&
          opl->report_.GetWinnerParty()[0].list_candidates_[0].GetName()
          != second_choice)
      {
        candidate_is_random = true;
        break;
      }
    }
  }

  // Even after 1000 runs, the algorithm above can sometimes not
  // pick up randomness due to sheer chance.
  // Run the test again for a few times.
  // If this test is passed at least once,
  // we know that tiebreaker has done its part.
  EXPECT_EQ(candidate_is_random, true ) <<
      "FAIL: Tiebreaker does not show randomness in tied candidates in 1000 runs";


};

#endif  // OPL_TIEBREAKER_TEST
