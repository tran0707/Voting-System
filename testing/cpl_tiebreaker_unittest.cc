/* STUDENTS:  DO NOT EDIT THIS FILE.  INSTEAD, MODIFY YOUR OWN PROJECT
 * CODE TO FIT THE SPECIFICATION GIVEN BY THE TESTS IN THIS FILE.
 *
 * If you DO modify it, we overwrite it with a fresh version from our repo
 * when grading, so you can't use it to fudge the tests anyway.
 *
 * This file is used by the CS5801 auto-grading system.
 *
 * Please note, the assessment tests for grading, will use the same include
 * files, class names, and function names for accessing students' code that you
 * find in this file.  So students, if you write your code so that it passes
 * these feedback tests, you can be assured that the auto-grader will at least
 * be able to properly link with your code.
 */
/*******************************************************************************
* This test file are inspired by CS5801 Fall 2019
******************************************************************************/
 #ifdef CPL_TIEBREAKER_TEST

/*******************************************************************************
 * Includes
 ******************************************************************************/
#include <cmath>
#include <gtest/gtest.h>
#include "src/cpl.h"
#include <unistd.h>
class CPLTiebreakerTest : public ::testing::Test {

 protected:
  virtual void SetUp() {
    // Initialize anything for TESTS
    cpl->ReadFile("cpl_tiebreaker_1.csv");

  }

  CPL *cpl = new CPL();

};

/*******************************************************************************
 * Test Cases
 ******************************************************************************/

TEST_F(CPLTiebreakerTest, AuditFile) {
  cpl->Audit();

  // Checking input to prevent early errors
  EXPECT_EQ(cpl->report_.GetNumTotalCandidates(), 17 ) << "FAIL";
  EXPECT_EQ(cpl->report_.GetNumBallots(), 100 ) << "FAIL";
  EXPECT_EQ(cpl->report_.GetNumTotalSeats(), 10 ) << "FAIL";

  // Checking ballot numbers
  EXPECT_EQ(cpl->report_.GetWinnerParty().size(), 4 ) << "FAIL";
  EXPECT_EQ(cpl->report_.GetWinnerParty()[0].GetBallotList().size(), 25 ) << "FAIL";
  EXPECT_EQ(cpl->report_.GetWinnerParty()[1].GetBallotList().size(), 25 ) << "FAIL";
  EXPECT_EQ(cpl->report_.GetWinnerParty()[2].GetBallotList().size(), 25 ) << "FAIL";
  EXPECT_EQ(cpl->report_.GetWinnerParty()[3].GetBallotList().size(), 25 ) << "FAIL";

  // Since it is a four-way tie, each party must have at least 2 winners
  EXPECT_GE(cpl->report_.GetWinnerParty()[0].list_candidates_.size(), 2 ) << "FAIL";
  EXPECT_GE(cpl->report_.GetWinnerParty()[1].list_candidates_.size(), 2 ) << "FAIL";
  EXPECT_GE(cpl->report_.GetWinnerParty()[2].list_candidates_.size(), 2 ) << "FAIL";
  EXPECT_GE(cpl->report_.GetWinnerParty()[3].list_candidates_.size(), 2 ) << "FAIL";

  // The top 1 candidate of each party
  // Four-way tie. They must be present.
  EXPECT_EQ(cpl->report_.GetWinnerParty()[0].list_candidates_[0].GetName(), "Pike" ) << "FAIL";
  EXPECT_EQ(cpl->report_.GetWinnerParty()[1].list_candidates_[0].GetName(), "Deutsch" ) << "FAIL";
  EXPECT_EQ(cpl->report_.GetWinnerParty()[2].list_candidates_[0].GetName(), "Jones" ) << "FAIL";
  EXPECT_EQ(cpl->report_.GetWinnerParty()[3].list_candidates_[0].GetName(), "Perez" ) << "FAIL";

  // Random function testing
  // 1 - Using the sizes of winner parties to determine if any changes are made.
  // If so, then we can confirm that the tiebreaker is working on the party level.

  // Store the first run's size of winner parties for comparison later
  std::vector<int> originalSizes;
  for (int i = 0; i < 4; i++) {
    originalSizes.push_back(cpl->report_.GetWinnerParty()[i].list_candidates_.size());
  }


  std::vector<int> newSizes;
  bool is_random = false;

  // Run Audit 21 times. If any of these times is different than
  // the original sizes of the winner parties, 
  // then we know that the tiebreaker is working.
  for (int i = 0; i < 21; i++) {
    cpl->Audit();
    newSizes.clear();
    for (int i = 0; i < 4; i++) {
      newSizes.push_back(cpl->report_.GetWinnerParty()[i].list_candidates_.size());
    }
    if (originalSizes != newSizes) {
      is_random = true;
      // Exit for loop.
      // No more Audit needed now that we know the function is random.
      break;
    }
  }

  EXPECT_EQ(is_random, true ) << "FAIL: Tiebreaker's randomness has not been detected in 21 runs.";
};

#endif  // CPL_TIEBREAKER_TEST
